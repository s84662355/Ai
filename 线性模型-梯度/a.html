<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>K均值聚类算法可视化</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.8/dist/chart.umd.min.js"></script>
  
  <!-- Tailwind 配置 -->
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            primary: '#3B82F6',
            secondary: '#10B981',
            accent: '#8B5CF6',
            neutral: '#1F2937',
          },
          fontFamily: {
            sans: ['Inter', 'system-ui', 'sans-serif'],
          },
        },
      }
    }
  </script>
  
  <style type="text/tailwindcss">
    @layer utilities {
      .content-auto {
        content-visibility: auto;
      }
      .transition-smooth {
        transition: all 0.3s ease-in-out;
      }
      .shadow-custom {
        box-shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1), 0 8px 10px -6px rgba(0, 0, 0, 0.1);
      }
    }
  </style>
</head>
<body class="bg-gray-50 font-sans">
  <div class="container mx-auto px-4 py-8 max-w-6xl">
    <!-- 页面标题 -->
    <header class="mb-8 text-center">
      <h1 class="text-[clamp(1.8rem,4vw,2.8rem)] font-bold text-neutral mb-2">K均值聚类算法可视化</h1>
      <p class="text-gray-600 max-w-2xl mx-auto">通过动画直观了解K均值聚类算法的工作原理，不同颜色的点表示不同的聚类结果</p>
    </header>
    
    <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
      <!-- 控制面板 -->
      <div class="lg:col-span-1">
        <div class="bg-white rounded-xl shadow-custom p-6 h-full">
          <h2 class="text-xl font-semibold text-neutral mb-4 flex items-center">
            <i class="fa fa-sliders mr-2 text-primary"></i>控制面板
          </h2>
          
          <div class="space-y-6">
            <!-- 数据点数量控制 -->
            <div>
              <label class="block text-sm font-medium text-gray-700 mb-2">数据点数量</label>
              <div class="flex items-center">
                <input type="range" id="pointCount" min="10" max="100" value="60" 
                       class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-primary">
                <span id="pointCountValue" class="ml-3 text-sm font-medium text-gray-700 min-w-[30px]">60</span>
              </div>
            </div>
            
            <!-- 聚类数量控制 -->
            <div>
              <label class="block text-sm font-medium text-gray-700 mb-2">聚类数量 (K)</label>
              <div class="flex items-center">
                <input type="range" id="kValue" min="2" max="10" value="3" 
                       class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-primary">
                <span id="kValueValue" class="ml-3 text-sm font-medium text-gray-700 min-w-[30px]">3</span>
              </div>
            </div>
            
            <!-- 最大迭代次数 -->
            <div>
              <label class="block text-sm font-medium text-gray-700 mb-2">最大迭代次数</label>
              <div class="flex items-center">
                <input type="range" id="maxIterations" min="5" max="50" value="20" 
                       class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-primary">
                <span id="maxIterationsValue" class="ml-3 text-sm font-medium text-gray-700 min-w-[30px]">20</span>
              </div>
            </div>
            
            <!-- 动画速度 -->
            <div>
              <label class="block text-sm font-medium text-gray-700 mb-2">动画速度</label>
              <div class="flex items-center">
                <input type="range" id="animationSpeed" min="100" max="1000" value="500" 
                       class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-primary">
                <span id="animationSpeedValue" class="ml-3 text-sm font-medium text-gray-700 min-w-[30px]">500</span>
              </div>
              <p class="text-xs text-gray-500 mt-1">数值越大，动画越慢</p>
            </div>
            
            <!-- 按钮组 -->
            <div class="flex space-x-3 pt-2">
              <button id="runButton" class="flex-1 bg-primary hover:bg-primary/90 text-white font-medium py-2 px-4 rounded-lg transition-smooth flex items-center justify-center">
                <i class="fa fa-play mr-2"></i>运行算法
              </button>
              <button id="resetButton" class="bg-gray-200 hover:bg-gray-300 text-gray-700 font-medium py-2 px-4 rounded-lg transition-smooth flex items-center justify-center">
                <i class="fa fa-refresh mr-2"></i>重置
              </button>
            </div>
            
            <!-- 算法状态 -->
            <div class="mt-6">
              <h3 class="text-sm font-medium text-gray-700 mb-2">算法状态</h3>
              <div class="bg-gray-50 p-3 rounded-lg h-32 overflow-auto text-sm">
                <p id="statusLog" class="text-gray-600">准备就绪。请点击"运行算法"开始。</p>
              </div>
            </div>
          </div>
        </div>
      </div>
      
      <!-- 可视化区域 -->
      <div class="lg:col-span-2">
        <div class="bg-white rounded-xl shadow-custom p-6 h-full">
          <div class="flex justify-between items-center mb-4">
            <h2 class="text-xl font-semibold text-neutral flex items-center">
              <i class="fa fa-area-chart mr-2 text-primary"></i>聚类过程可视化
            </h2>
            <div class="flex items-center space-x-4">
              <div class="flex items-center">
                <span class="inline-block w-3 h-3 rounded-full bg-gray-400 mr-2"></span>
                <span class="text-sm text-gray-600">未分类</span>
              </div>
              <div id="legend" class="flex flex-wrap gap-2">
                <!-- 动态生成的图例 -->
              </div>
            </div>
          </div>
          
          <!-- 图表容器 -->
          <div class="relative h-[500px] w-full">
            <canvas id="kmeansChart"></canvas>
          </div>
          
          <!-- 迭代进度 -->
          <div class="mt-4">
            <div class="flex justify-between text-sm text-gray-600 mb-1">
              <span>迭代进度</span>
              <span id="iterationCounter">0 / 0</span>
            </div>
            <div class="w-full bg-gray-200 rounded-full h-2">
              <div id="progressBar" class="bg-primary h-2 rounded-full" style="width: 0%"></div>
            </div>
          </div>
        </div>
      </div>
    </div>
    
    <!-- 算法说明 -->
    <div class="mt-8 bg-white rounded-xl shadow-custom p-6">
      <h2 class="text-xl font-semibold text-neutral mb-4 flex items-center">
        <i class="fa fa-info-circle mr-2 text-primary"></i>K均值聚类算法原理
      </h2>
      <div class="prose max-w-none">
        <p>K均值聚类是一种无监督学习算法，用于将数据点划分为K个不同的簇。算法的核心思想是通过迭代优化，最小化每个数据点到其所属簇中心的距离平方和。</p>
        <h3 class="text-lg font-semibold mt-4 mb-2">算法步骤：</h3>
        <ol class="list-decimal pl-5 space-y-1">
          <li>随机选择K个点作为初始聚类中心</li>
          <li>将每个数据点分配到距离最近的聚类中心</li>
          <li>重新计算每个聚类的中心（均值）</li>
          <li>重复步骤2和3，直到聚类中心不再变化或达到最大迭代次数</li>
        </ol>
        <h3 class="text-lg font-semibold mt-4 mb-2">应用场景：</h3>
        <ul class="list-disc pl-5 space-y-1">
          <li>客户细分</li>
          <li>图像分割</li>
          <li>文档分类</li>
          <li>异常检测</li>
          <li>数据压缩</li>
        </ul>
      </div>
    </div>
    
    <!-- 页脚 -->
    <footer class="mt-8 text-center text-gray-500 text-sm">
      <p>© 2025 K均值聚类算法可视化工具 | 使用 HTML, JavaScript 和 Chart.js 构建</p>
    </footer>
  </div>

  <script>
    // 全局变量
    let chart;
    let points = [];
    let centroids = [];
    let clusters = [];
    let iterations = [];
    let currentIteration = 0;
    let animationInterval;
    let isRunning = false;
    
    // 颜色池 - 为不同聚类分配颜色
    const colors = [
      '#3B82F6', // 蓝色
      '#10B981', // 绿色
      '#8B5CF6', // 紫色
      '#F59E0B', // 橙色
      '#EF4444', // 红色
      '#EC4899', // 粉色
      '#06B6D4', // 青色
      '#6366F1', // 靛蓝色
      '#14B8A6', // 绿松石色
      '#F97316', // 琥珀色
    ];
    
    // DOM 元素
    const pointCountSlider = document.getElementById('pointCount');
    const pointCountValue = document.getElementById('pointCountValue');
    const kValueSlider = document.getElementById('kValue');
    const kValueValue = document.getElementById('kValueValue');
    const maxIterationsSlider = document.getElementById('maxIterations');
    const maxIterationsValue = document.getElementById('maxIterationsValue');
    const animationSpeedSlider = document.getElementById('animationSpeed');
    const animationSpeedValue = document.getElementById('animationSpeedValue');
    const runButton = document.getElementById('runButton');
    const resetButton = document.getElementById('resetButton');
    const statusLog = document.getElementById('statusLog');
    const iterationCounter = document.getElementById('iterationCounter');
    const progressBar = document.getElementById('progressBar');
    const legend = document.getElementById('legend');
    
    // 更新滑块值显示
    pointCountSlider.addEventListener('input', () => {
      pointCountValue.textContent = pointCountSlider.value;
    });
    
    kValueSlider.addEventListener('input', () => {
      kValueValue.textContent = kValueSlider.value;
      updateLegend();
    });
    
    maxIterationsSlider.addEventListener('input', () => {
      maxIterationsValue.textContent = maxIterationsSlider.value;
    });
    
    animationSpeedSlider.addEventListener('input', () => {
      animationSpeedValue.textContent = animationSpeedSlider.value;
    });
    
    // 初始化图表
    function initChart() {
      const ctx = document.getElementById('kmeansChart').getContext('2d');
      
      // 销毁现有图表
      if (chart) {
        chart.destroy();
      }
      
      // 创建新图表
      chart = new Chart(ctx, {
        type: 'scatter',
        data: {
          datasets: [{
            label: '数据点',
            data: points.map((p, i) => ({
              x: p.x,
              y: p.y,
              index: i,
              cluster: -1 // -1 表示未分类
            })),
            backgroundColor: 'rgba(200, 200, 200, 0.7)',
            borderColor: 'rgba(150, 150, 150, 1)',
            borderWidth: 1,
            pointRadius: 5,
            pointHoverRadius: 7
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          animation: {
            duration: 0 // 禁用初始动画
          },
          scales: {
            x: {
              type: 'linear',
              position: 'center',
              grid: {
                color: 'rgba(200, 200, 200, 0.2)'
              },
              ticks: {
                color: 'rgba(100, 100, 100, 0.7)'
              }
            },
            y: {
              type: 'linear',
              position: 'center',
              grid: {
                color: 'rgba(200, 200, 200, 0.2)'
              },
              ticks: {
                color: 'rgba(100, 100, 100, 0.7)'
              }
            }
          },
          plugins: {
            legend: {
              display: false
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  const point = context.raw;
                  if (point.cluster === -1) {
                    return [`坐标: (${point.x.toFixed(2)}, ${point.y.toFixed(2)})`, '类别: 未分类'];
                  }
                  return [`坐标: (${point.x.toFixed(2)}, ${point.y.toFixed(2)})`, `类别: ${point.cluster + 1}`];
                }
              }
            }
          }
        }
      });
    }
    
    // 生成随机数据点
    function generatePoints(count) {
      points = [];
      
      // 生成几个聚类中心，让数据点围绕这些中心分布
      const numNaturalClusters = Math.min(5, Math.floor(count / 10));
      const naturalCenters = [];
      
      for (let i = 0; i < numNaturalClusters; i++) {
        naturalCenters.push({
          x: Math.random() * 80 + 10,
          y: Math.random() * 80 + 10
        });
      }
      
      // 生成数据点
      for (let i = 0; i < count; i++) {
        // 随机选择一个自然中心
        const center = naturalCenters[Math.floor(Math.random() * naturalCenters.length)];
        
        // 在自然中心周围生成点
        const x = center.x + (Math.random() - 0.5) * 15;
        const y = center.y + (Math.random() - 0.5) * 15;
        
        points.push({ x, y });
      }
      
      // 更新图表
      if (chart) {
        chart.data.datasets[0].data = points.map((p, i) => ({
          x: p.x,
          y: p.y,
          index: i,
          cluster: -1
        }));
        chart.update();
      }
    }
    
    // 更新图例
    function updateLegend() {
      legend.innerHTML = '';
      const k = parseInt(kValueSlider.value);
      
      for (let i = 0; i < k; i++) {
        const item = document.createElement('div');
        item.className = 'flex items-center';
        item.innerHTML = `
          <span class="inline-block w-3 h-3 rounded-full" style="background-color: ${colors[i]}"></span>
          <span class="text-sm text-gray-600 ml-1">聚类 ${i + 1}</span>
        `;
        legend.appendChild(item);
      }
    }
    
    // 初始化K均值算法
    function initializeKMeans() {
      const k = parseInt(kValueSlider.value);
      
      // 随机选择K个初始中心点
      centroids = [];
      const usedIndices = new Set();
      
      while (centroids.length < k) {
        const index = Math.floor(Math.random() * points.length);
        if (!usedIndices.has(index)) {
          usedIndices.add(index);
          centroids.push({
            x: points[index].x,
            y: points[index].y,
            index: centroids.length
          });
        }
      }
      
      // 重置聚类结果
      clusters = new Array(points.length).fill(-1);
      
      // 重置迭代记录
      iterations = [];
      iterations.push({
        points: points.map(p => ({ ...p })),
        centroids: centroids.map(c => ({ ...c })),
        clusters: [...clusters]
      });
      
      // 更新图表
      updateChart(0);
      
      // 更新状态
      logStatus(`已初始化K均值算法，K = ${k}`);
      logStatus(`随机选择了 ${k} 个初始中心点`);
    }
    
    // 运行K均值算法
    function runKMeans(maxIterations) {
      if (isRunning) return;
      
      isRunning = true;
      runButton.disabled = true;
      runButton.innerHTML = '<i class="fa fa-spinner fa-spin mr-2"></i>运行中...';
      
      // 初始化算法
      initializeKMeans();
      
      // 当前迭代
      let iteration = 0;
      let changed = true;
      
      // 使用 setTimeout 分步执行算法，以便观察每一步
      const executeStep = () => {
        if (iteration >= maxIterations || !changed) {
          // 算法完成
          logStatus(`算法完成，共执行 ${iteration} 次迭代`);
          isRunning = false;
          runButton.disabled = false;
          runButton.innerHTML = '<i class="fa fa-play mr-2"></i>运行算法';
          
          // 显示最终结果
          currentIteration = iterations.length - 1;
          updateChart(currentIteration);
          updateProgressBar();
          
          return;
        }
        
        // 记录上一次的聚类结果
        const prevClusters = [...clusters];
        
        // 步骤1: 分配数据点到最近的聚类中心
        for (let i = 0; i < points.length; i++) {
          let minDistance = Infinity;
          let closestCentroid = -1;
          
          for (let j = 0; j < centroids.length; j++) {
            const distance = Math.sqrt(
              Math.pow(points[i].x - centroids[j].x, 2) + 
              Math.pow(points[i].y - centroids[j].y, 2)
            );
            
            if (distance < minDistance) {
              minDistance = distance;
              closestCentroid = j;
            }
          }
          
          clusters[i] = closestCentroid;
        }
        
        // 检查是否有变化
        changed = false;
        for (let i = 0; i < clusters.length; i++) {
          if (clusters[i] !== prevClusters[i]) {
            changed = true;
            break;
          }
        }
        
        // 步骤2: 更新聚类中心
        for (let j = 0; j < centroids.length; j++) {
          let sumX = 0;
          let sumY = 0;
          let count = 0;
          
          for (let i = 0; i < points.length; i++) {
            if (clusters[i] === j) {
              sumX += points[i].x;
              sumY += points[i].y;
              count++;
            }
          }
          
          if (count > 0) {
            centroids[j].x = sumX / count;
            centroids[j].y = sumY / count;
          }
        }
        
        // 记录当前迭代状态
        iterations.push({
          points: points.map(p => ({ ...p })),
          centroids: centroids.map(c => ({ ...c })),
          clusters: [...clusters]
        });
        
        // 更新图表
        currentIteration = iteration + 1;
        updateChart(currentIteration);
        updateProgressBar();
        
        // 记录状态
        logStatus(`完成迭代 ${iteration + 1}${changed ? '' : '，聚类中心不再变化'}`);
        
        iteration++;
        
        // 继续下一步
        setTimeout(executeStep, 1000 - parseInt(animationSpeedSlider.value));
      };
      
      // 开始执行
      setTimeout(executeStep, 1000 - parseInt(animationSpeedSlider.value));
    }
    
    // 动画显示聚类过程
    function animateClustering() {
      if (iterations.length <= 1 || isRunning) return;
      
      isRunning = true;
      runButton.disabled = true;
      runButton.innerHTML = '<i class="fa fa-spinner fa-spin mr-2"></i>动画中...';
      
      currentIteration = 0;
      updateChart(currentIteration);
      updateProgressBar();
      
      const speed = parseInt(animationSpeedSlider.value);
      
      animationInterval = setInterval(() => {
        currentIteration++;
        
        if (currentIteration >= iterations.length) {
          clearInterval(animationInterval);
          isRunning = false;
          runButton.disabled = false;
          runButton.innerHTML = '<i class="fa fa-play mr-2"></i>运行算法';
          return;
        }
        
        updateChart(currentIteration);
        updateProgressBar();
      }, speed);
    }
    
    // 更新图表
    function updateChart(iterationIndex) {
      if (iterationIndex >= iterations.length) return;
      
      const iteration = iterations[iterationIndex];
      
      // 更新数据点
      const dataPoints = iteration.points.map((p, i) => ({
        x: p.x,
        y: p.y,
        index: i,
        cluster: iteration.clusters[i]
      }));
      
      // 更新数据集
      chart.data.datasets = [];
      
      // 添加未分类的点
      const unclassifiedPoints = dataPoints.filter(p => p.cluster === -1);
      if (unclassifiedPoints.length > 0) {
        chart.data.datasets.push({
          label: '未分类',
          data: unclassifiedPoints,
          backgroundColor: 'rgba(200, 200, 200, 0.7)',
          borderColor: 'rgba(150, 150, 150, 1)',
          borderWidth: 1,
          pointRadius: 5,
          pointHoverRadius: 7
        });
      }
      
      // 为每个聚类添加数据集
      const k = parseInt(kValueSlider.value);
      for (let j = 0; j < k; j++) {
        const clusterPoints = dataPoints.filter(p => p.cluster === j);
        if (clusterPoints.length > 0) {
          chart.data.datasets.push({
            label: `聚类 ${j + 1}`,
            data: clusterPoints,
            backgroundColor: `${colors[j]}80`, // 半透明
            borderColor: colors[j],
            borderWidth: 1,
            pointRadius: 5,
            pointHoverRadius: 7
          });
        }
      }
      
      // 添加聚类中心
      chart.data.datasets.push({
        label: '聚类中心',
        data: iteration.centroids,
        backgroundColor: 'rgba(0, 0, 0, 0.8)',
        borderColor: 'white',
        borderWidth: 2,
        pointRadius: 8,
        pointHoverRadius: 10,
        pointStyle: 'cross'
      });
      
      // 更新图表
      chart.update();
    }
    
    // 更新进度条
    function updateProgressBar() {
      const total = iterations.length - 1;
      const percent = (currentIteration / total) * 100;
      
      progressBar.style.width = `${Math.min(100, percent)}%`;
      iterationCounter.textContent = `${currentIteration} / ${total}`;
    }
    
    // 记录状态
    function logStatus(message) {
      const timestamp = new Date().toLocaleTimeString();
      statusLog.innerHTML += `<p class="mb-1"><span class="text-gray-400 text-xs">${timestamp}</span> ${message}</p>`;
      statusLog.scrollTop = statusLog.scrollHeight;
    }
    
    // 重置所有
    function resetAll() {
      // 停止任何正在运行的动画
      if (isRunning) {
        clearInterval(animationInterval);
        isRunning = false;
      }
      
      // 生成新数据
      const count = parseInt(pointCountSlider.value);
      generatePoints(count);
      
      // 重置迭代
      iterations = [];
      currentIteration = 0;
      
      // 更新图表
      updateChart(0);
      updateProgressBar();
      
      // 清空状态日志
      statusLog.innerHTML = '准备就绪。请点击"运行算法"开始。';
      
      // 重置按钮状态
      runButton.disabled = false;
      runButton.innerHTML = '<i class="fa fa-play mr-2"></i>运行算法';
    }
    
    // 事件监听器
    runButton.addEventListener('click', () => {
      if (!isRunning && iterations.length > 1) {
        // 如果已经运行过算法，直接播放动画
        animateClustering();
      } else {
        // 否则重新运行算法
        const maxIterations = parseInt(maxIterationsSlider.value);
        runKMeans(maxIterations);
      }
    });
    
    resetButton.addEventListener('click', resetAll);
    
    // 初始化页面
    function init() {
      updateLegend();
      resetAll();
    }
    
    // 页面加载完成后初始化
    window.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>    